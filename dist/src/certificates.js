"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const createDebug = require("debug");
const fs_1 = require("fs");
const mkdirp_1 = require("mkdirp");
const certificate_authority_1 = require("./certificate-authority");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const debug = createDebug('devcert:certificates');
/**
 * Generate a domain certificate signed by the devcert root CA. Domain
 * certificates are cached in their own directories under
 * CONFIG_ROOT/domains/<domain>, and reused on subsequent requests. Because the
 * individual domain certificates are signed by the devcert root CA (which was
 * added to the OS/browser trust stores), they are trusted.
 */
async function generateDomainCertificate(commonName, alternativeNames, certOptions) {
    mkdirp_1.sync(utils_1.pathForDomain(commonName));
    debug(`Generating private key for ${commonName}`);
    const domainKeyPath = utils_1.pathForDomain(commonName, 'private-key.key');
    generateKey(domainKeyPath);
    debug(`Generating certificate signing request for ${commonName}`);
    const csrFile = utils_1.pathForDomain(commonName, `certificate-signing-request.csr`);
    await constants_1.withDomainSigningRequestConfig(commonName, { alternativeNames }, configpath => {
        utils_1.openssl(`req -new -config "${configpath}" -key "${domainKeyPath}" -out "${csrFile}" -days ${certOptions.domainCertExpiry}`, `generating CSR for ${commonName}`);
    });
    debug(`Generating certificate for ${commonName} from signing request and signing with root CA`);
    const domainCertPath = utils_1.pathForDomain(commonName, `certificate.crt`);
    await certificate_authority_1.withCertificateAuthorityCredentials(async ({ caKeyPath, caCertPath }) => {
        await constants_1.withDomainCertificateConfig(commonName, alternativeNames, domainCertConfigPath => {
            utils_1.openssl(`ca -config "${domainCertConfigPath}" -in "${csrFile}" -out "${domainCertPath}" -keyfile "${caKeyPath}" -cert "${caCertPath}" -days ${certOptions.domainCertExpiry} -batch`, `signing cert for ${commonName} with root ca`);
        });
    });
}
exports.generateDomainCertificate = generateDomainCertificate;
function isFile(pth) {
    return fs_1.statSync(pth).isFile();
}
/**
 * Revokes a domain certificate signed by the devcert root CA and deletes it.
 */
async function revokeDomainCertificate(commonName) {
    debug(`Revoking certificate for ${commonName}`);
    const domainCertPath = utils_1.certPathForDomain(commonName);
    assert(fs_1.existsSync(domainCertPath), 'domainCertPath must exist');
    assert(isFile(domainCertPath), 'domainCertPath must be a file');
    debug('domainCertPath', domainCertPath);
    assert(fs_1.readFileSync(domainCertPath).toString().length > 0, 'domainCert must be non-empty');
    await certificate_authority_1.withCertificateAuthorityCredentials(async ({ caKeyPath, caCertPath }) => {
        debug('caKeyPath', caKeyPath);
        debug('caCertPath', caCertPath);
        assert(fs_1.existsSync(caCertPath), 'ca cert must exist');
        assert(isFile(caCertPath), 'ca cert must be a file');
        assert(fs_1.existsSync(caKeyPath), 'ca key must exist');
        assert(isFile(caKeyPath), 'ca key must be a file');
        await constants_1.withDomainCertificateConfig(commonName, [], domainCertConfigPath => {
            assert(fs_1.existsSync(domainCertConfigPath), 'domainCertConfigPath must exist');
            assert(isFile(domainCertConfigPath), 'domainCertConfigPath must be a file');
            utils_1.openssl(`ca -config "${domainCertConfigPath}" -revoke "${domainCertPath}" -keyfile "${caKeyPath}" -cert "${caCertPath}"`, `revoking domain certificate for ${commonName}`);
        });
    }).catch(err => {
        throw new Error(`Problem revoking certificate\n${err}`);
    });
}
exports.revokeDomainCertificate = revokeDomainCertificate;
// Generate a cryptographic key, used to sign certificates or certificate signing requests.
function generateKey(filename) {
    debug(`generateKey: ${filename}`);
    utils_1.openssl(`genrsa -out "${filename}" 2048`, 'generating RSA key');
    fs_1.chmodSync(filename, 400);
}
exports.generateKey = generateKey;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2VydGlmaWNhdGVzLmpzIiwic291cmNlUm9vdCI6Ii4vIiwic291cmNlcyI6WyJzcmMvY2VydGlmaWNhdGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsaUNBQWlDO0FBQ2pDLHFDQUFxQztBQUNyQywyQkFBNEU7QUFDNUUsbUNBQXdDO0FBQ3hDLG1FQUE4RTtBQUM5RSwyQ0FHcUI7QUFFckIsbUNBQW9FO0FBRXBFLE1BQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0FBRWxEOzs7Ozs7R0FNRztBQUNJLEtBQUssVUFBVSx5QkFBeUIsQ0FDN0MsVUFBa0IsRUFDbEIsZ0JBQTBCLEVBQzFCLFdBQXdCO0lBRXhCLGFBQU0sQ0FBQyxxQkFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7SUFFbEMsS0FBSyxDQUFDLDhCQUE4QixVQUFVLEVBQUUsQ0FBQyxDQUFDO0lBQ2xELE1BQU0sYUFBYSxHQUFHLHFCQUFhLENBQUMsVUFBVSxFQUFFLGlCQUFpQixDQUFDLENBQUM7SUFDbkUsV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBRTNCLEtBQUssQ0FBQyw4Q0FBOEMsVUFBVSxFQUFFLENBQUMsQ0FBQztJQUNsRSxNQUFNLE9BQU8sR0FBRyxxQkFBYSxDQUFDLFVBQVUsRUFBRSxpQ0FBaUMsQ0FBQyxDQUFDO0lBQzdFLE1BQU0sMENBQThCLENBQ2xDLFVBQVUsRUFDVixFQUFFLGdCQUFnQixFQUFFLEVBQ3BCLFVBQVUsQ0FBQyxFQUFFO1FBQ1gsZUFBTyxDQUNMLHFCQUFxQixVQUFVLFdBQVcsYUFBYSxXQUFXLE9BQU8sV0FBVyxXQUFXLENBQUMsZ0JBQWdCLEVBQUUsRUFDbEgsc0JBQXNCLFVBQVUsRUFBRSxDQUNuQyxDQUFDO0lBQ0osQ0FBQyxDQUNGLENBQUM7SUFFRixLQUFLLENBQ0gsOEJBQThCLFVBQVUsZ0RBQWdELENBQ3pGLENBQUM7SUFDRixNQUFNLGNBQWMsR0FBRyxxQkFBYSxDQUFDLFVBQVUsRUFBRSxpQkFB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QUUsR0FBRyxDQUFDLENBQUM7QUFDdkIsQ0FBQztBQUpELGtDQUlDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgKiBhcyBjcmVhdGVEZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgeyBjaG1vZFN5bmMgYXMgY2htb2QsIGV4aXN0c1N5bmMsIHN0YXRTeW5jLCByZWFkRmlsZVN5bmMgfSBmcm9tICdmcyc7XG5pbXBvcnQgeyBzeW5jIGFzIG1rZGlycCB9IGZyb20gJ21rZGlycCc7XG5pbXBvcnQgeyB3aXRoQ2VydGlmaWNhdGVBdXRob3JpdHlDcmVkZW50aWFscyB9IGZyb20gJy4vY2VydGlmaWNhdGUtYXV0aG9yaXR5JztcbmltcG9ydCB7XG4gIHdpdGhEb21haW5DZXJ0aWZpY2F0ZUNvbmZpZyxcbiAgd2l0aERvbWFpblNpZ25pbmdSZXF1ZXN0Q29uZmlnXG59IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IENlcnRPcHRpb25zIH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBvcGVuc3NsLCBwYXRoRm9yRG9tYWluLCBjZXJ0UGF0aEZvckRvbWFpbiB9IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBkZWJ1ZyA9IGNyZWF0ZURlYnVnKCdkZXZjZXJ0OmNlcnRpZmljYXRlcycpO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgZG9tYWluIGNlcnRpZmljYXRlIHNpZ25lZCBieSB0aGUgZGV2Y2VydCByb290IENBLiBEb21haW5cbiAqIGNlcnRpZmljYXRlcyBhcmUgY2FjaGVkIGluIHRoZWlyIG93biBkaXJlY3RvcmllcyB1bmRlclxuICogQ09ORklHX1JPT1QvZG9tYWlucy88ZG9tYWluPiwgYW5kIHJldXNlZCBvbiBzdWJzZXF1ZW50IHJlcXVlc3RzLiBCZWNhdXNlIHRoZVxuICogaW5kaXZpZHVhbCBkb21haW4gY2VydGlmaWNhdGVzIGFyZSBzaWduZWQgYnkgdGhlIGRldmNlcnQgcm9vdCBDQSAod2hpY2ggd2FzXG4gKiBhZGRlZCB0byB0aGUgT1MvYnJvd3NlciB0cnVzdCBzdG9yZXMpLCB0aGV5IGFyZSB0cnVzdGVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVEb21haW5DZXJ0aWZpY2F0ZShcbiAgY29tbW9uTmFtZTogc3RyaW5nLFxuICBhbHRlcm5hdGl2ZU5hbWVzOiBzdHJpbmdbXSxcbiAgY2VydE9wdGlvbnM6IENlcnRPcHRpb25zXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgbWtkaXJwKHBhdGhGb3JEb21haW4oY29tbW9uTmFtZSkpO1xuXG4gIGRlYnVnKGBHZW5lcmF0aW5nIHByaXZhdGUga2V5IGZvciAke2NvbW1vbk5hbWV9YCk7XG4gIGNvbnN0IGRvbWFpbktleVBhdGggPSBwYXRoRm9yRG9tYWluKGNvbW1vbk5hbWUsICdwcml2YXRlLWtleS5rZXknKTtcbiAgZ2VuZXJhdGVLZXkoZG9tYWluS2V5UGF0aCk7XG5cbiAgZGVidWcoYEdlbmVyYXRpbmcgY2VydGlmaWNhdGUgc2lnbmluZyByZXF1ZXN0IGZvciAke2NvbW1vbk5hbWV9YCk7XG4gIGNvbnN0IGNzckZpbGUgPSBwYXRoRm9yRG9tYWluKGNvbW1vbk5hbWUsIGBjZXJ0aWZpY2F0ZS1zaWduaW5nLXJlcXVlc3QuY3NyYCk7XG4gIGF3YWl0IHdpdGhEb21haW5TaWduaW5nUmVxdWVzdENvbmZpZyhcbiAgICBjb21tb25OYW1lLFxuICAgIHsgYWx0ZXJuYXRpdmVOYW1lcyB9LFxuICAgIGNvbmZpZ3BhdGggPT4ge1xuICAgICAgb3BlbnNzbChcbiAgICAgICAgYHJlcSAtbmV3IC1jb25maWcgXCIke2NvbmZpZ3BhdGh9XCIgLWtleSBcIiR7ZG9tYWluS2V5UGF0aH1cIiAtb3V0IFwiJHtjc3JGaWxlfVwiIC1kYXlzICR7Y2VydE9wdGlvbnMuZG9tYWluQ2VydEV4cGlyeX1gLFxuICAgICAgICBgZ2VuZXJhdGluZyBDU1IgZm9yICR7Y29tbW9uTmFtZX1gXG4gICAgICApO1xuICAgIH1cbiAgKTtcblxuICBkZWJ1ZyhcbiAgICBgR2VuZXJhdGluZyBjZXJ0aWZpY2F0ZSBmb3IgJHtjb21tb25OYW1lfSBmcm9tIHNpZ25pbmcgcmVxdWVzdCBhbmQgc2lnbmluZyB3aXRoIHJvb3QgQ0FgXG4gICk7XG4gIGNvbnN0IGRvbWFpbkNlcnRQYXRoID0gcGF0aEZvckRvbWFpbihjb21tb25OYW1lLCBgY2VydGlmaWNhdGUuY3J0YCk7XG5cbiAgYXdhaXQgd2l0aENlcnRpZmljYXRlQXV0aG9yaXR5Q3JlZGVudGlhbHMoXG4gICAgYXN5bmMgKHsgY2FLZXlQYXRoLCBjYUNlcnRQYXRoIH0pID0+IHtcbiAgICAgIGF3YWl0IHdpdGhEb21haW5DZXJ0aWZpY2F0ZUNvbmZpZyhcbiAgICAgICAgY29tbW9uTmFtZSxcbiAgICAgICAgYWx0ZXJuYXRpdmVOYW1lcyxcbiAgICAgICAgZG9tYWluQ2VydENvbmZpZ1BhdGggPT4ge1xuICAgICAgICAgIG9wZW5zc2woXG4gICAgICAgICAgICBgY2EgLWNvbmZpZyBcIiR7ZG9tYWluQ2VydENvbmZpZ1BhdGh9XCIgLWluIFwiJHtjc3JGaWxlfVwiIC1vdXQgXCIke2RvbWFpbkNlcnRQYXRofVwiIC1rZXlmaWxlIFwiJHtjYUtleVBhdGh9XCIgLWNlcnQgXCIke2NhQ2VydFBhdGh9XCIgLWRheXMgJHtjZXJ0T3B0aW9ucy5kb21haW5DZXJ0RXhwaXJ5fSAtYmF0Y2hgLFxuICAgICAgICAgICAgYHNpZ25pbmcgY2VydCBmb3IgJHtjb21tb25OYW1lfSB3aXRoIHJvb3QgY2FgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzRmlsZShwdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gc3RhdFN5bmMocHRoKS5pc0ZpbGUoKTtcbn1cblxuLyoqXG4gKiBSZXZva2VzIGEgZG9tYWluIGNlcnRpZmljYXRlIHNpZ25lZCBieSB0aGUgZGV2Y2VydCByb290IENBIGFuZCBkZWxldGVzIGl0LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmV2b2tlRG9tYWluQ2VydGlmaWNhdGUoXG4gIGNvbW1vbk5hbWU6IHN0cmluZ1xuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGRlYnVnKGBSZXZva2luZyBjZXJ0aWZpY2F0ZSBmb3IgJHtjb21tb25OYW1lfWApO1xuICBjb25zdCBkb21haW5DZXJ0UGF0aCA9IGNlcnRQYXRoRm9yRG9tYWluKGNvbW1vbk5hbWUpO1xuICBhc3NlcnQoZXhpc3RzU3luYyhkb21haW5DZXJ0UGF0aCksICdkb21haW5DZXJ0UGF0aCBtdXN0IGV4aXN0Jyk7XG4gIGFzc2VydChpc0ZpbGUoZG9tYWluQ2VydFBhdGgpLCAnZG9tYWluQ2VydFBhdGggbXVzdCBiZSBhIGZpbGUnKTtcbiAgZGVidWcoJ2RvbWFpbkNlcnRQYXRoJywgZG9tYWluQ2VydFBhdGgpO1xuXG4gIGFzc2VydChcbiAgICByZWFkRmlsZVN5bmMoZG9tYWluQ2VydFBhdGgpLnRvU3RyaW5nKCkubGVuZ3RoID4gMCxcbiAgICAnZG9tYWluQ2VydCBtdXN0IGJlIG5vbi1lbXB0eSdcbiAgKTtcbiAgYXdhaXQgd2l0aENlcnRpZmljYXRlQXV0aG9yaXR5Q3JlZGVudGlhbHMoXG4gICAgYXN5bmMgKHsgY2FLZXlQYXRoLCBjYUNlcnRQYXRoIH0pID0+IHtcbiAgICAgIGRlYnVnKCdjYUtleVBhdGgnLCBjYUtleVBhdGgpO1xuICAgICAgZGVidWcoJ2NhQ2VydFBhdGgnLCBjYUNlcnRQYXRoKTtcbiAgICAgIGFzc2VydChleGlzdHNTeW5jKGNhQ2VydFBhdGgpLCAnY2EgY2VydCBtdXN0IGV4aXN0Jyk7XG4gICAgICBhc3NlcnQoaXNGaWxlKGNhQ2VydFBhdGgpLCAnY2EgY2VydCBtdXN0IGJlIGEgZmlsZScpO1xuICAgICAgYXNzZXJ0KGV4aXN0c1N5bmMoY2FLZXlQYXRoKSwgJ2NhIGtleSBtdXN0IGV4aXN0Jyk7XG4gICAgICBhc3NlcnQoaXNGaWxlKGNhS2V5UGF0aCksICdjYSBrZXkgbXVzdCBiZSBhIGZpbGUnKTtcbiAgICAgIGF3YWl0IHdpdGhEb21haW5DZXJ0aWZpY2F0ZUNvbmZpZyhcbiAgICAgICAgY29tbW9uTmFtZSxcbiAgICAgICAgW10sXG4gICAgICAgIGRvbWFpbkNlcnRDb25maWdQYXRoID0+IHtcbiAgICAgICAgICBhc3NlcnQoXG4gICAgICAgICAgICBleGlzdHNTeW5jKGRvbWFpbkNlcnRDb25maWdQYXRoKSxcbiAgICAgICAgICAgICdkb21haW5DZXJ0Q29uZmlnUGF0aCBtdXN0IGV4aXN0J1xuICAgICAgICAgICk7XG4gICAgICAgICAgYXNzZXJ0KFxuICAgICAgICAgICAgaXNGaWxlKGRvbWFpbkNlcnRDb25maWdQYXRoKSxcbiAgICAgICAgICAgICdkb21haW5DZXJ0Q29uZmlnUGF0aCBtdXN0IGJlIGEgZmlsZSdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgb3BlbnNzbChcbiAgICAgICAgICAgIGBjYSAtY29uZmlnIFwiJHtkb21haW5DZXJ0Q29uZmlnUGF0aH1cIiAtcmV2b2tlIFwiJHtkb21haW5DZXJ0UGF0aH1cIiAta2V5ZmlsZSBcIiR7Y2FLZXlQYXRofVwiIC1jZXJ0IFwiJHtjYUNlcnRQYXRofVwiYCxcbiAgICAgICAgICAgIGByZXZva2luZyBkb21haW4gY2VydGlmaWNhdGUgZm9yICR7Y29tbW9uTmFtZX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICkuY2F0Y2goZXJyID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2JsZW0gcmV2b2tpbmcgY2VydGlmaWNhdGVcXG4ke2Vycn1gKTtcbiAgfSk7XG59XG5cbi8vIEdlbmVyYXRlIGEgY3J5cHRvZ3JhcGhpYyBrZXksIHVzZWQgdG8gc2lnbiBjZXJ0aWZpY2F0ZXMgb3IgY2VydGlmaWNhdGUgc2lnbmluZyByZXF1ZXN0cy5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUtleShmaWxlbmFtZTogc3RyaW5nKTogdm9pZCB7XG4gIGRlYnVnKGBnZW5lcmF0ZUtleTogJHtmaWxlbmFtZX1gKTtcbiAgb3BlbnNzbChgZ2VucnNhIC1vdXQgXCIke2ZpbGVuYW1lfVwiIDIwNDhgLCAnZ2VuZXJhdGluZyBSU0Ega2V5Jyk7XG4gIGNobW9kKGZpbGVuYW1lLCA0MDApO1xufVxuIl19