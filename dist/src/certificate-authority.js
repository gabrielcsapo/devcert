"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const createDebug = require("debug");
const constants_1 = require("./constants");
const platforms_1 = require("./platforms");
const utils_1 = require("./utils");
const certificates_1 = require("./certificates");
const path_1 = require("path");
const debug = createDebug('devcert:certificate-authority');
/**
 * Install the once-per-machine trusted root CA. We'll use this CA to sign
 * per-app certs.
 */
async function installCertificateAuthority(options = {}, certOptions) {
    debug(`Uninstalling existing certificates, which will be void once any existing CA is gone`);
    uninstall();
    constants_1.ensureConfigDirs();
    const tmp = utils_1.tmpDir();
    debug(`Making a temp working directory for files to copied in`);
    const rootKeyPath = path_1.join(tmp.name, 'ca.key');
    debug(`Generating the OpenSSL configuration needed to setup the certificate authority`);
    seedConfigFiles();
    debug(`Generating a private key`);
    certificates_1.generateKey(rootKeyPath);
    debug(`Generating a CA certificate`);
    utils_1.openssl(`req -new -x509 -config "${constants_1.caSelfSignConfig}" -key "${rootKeyPath}" -out "${constants_1.rootCACertPath}" -days ${certOptions.caCertExpiry}`, 'generating CA CSR');
    debug('Saving certificate authority credentials');
    await saveCertificateAuthorityCredentials(rootKeyPath);
    debug(`Adding the root certificate authority to trust stores`);
    await platforms_1.default.addToTrustStores(constants_1.rootCACertPath, options);
}
exports.default = installCertificateAuthority;
/**
 * Initializes the files OpenSSL needs to sign certificates as a certificate
 * authority, as well as our CA setup version
 */
function seedConfigFiles() {
    // This is v2 of the devcert certificate authority setup
    fs_1.writeFileSync(constants_1.caVersionFile, '2');
    // OpenSSL CA files
    fs_1.writeFileSync(constants_1.opensslDatabaseFilePath, '');
    fs_1.writeFileSync(constants_1.opensslSerialFilePath, '01');
}
async function withCertificateAuthorityCredentials(cb) {
    debug(`Retrieving devcert's certificate authority credentials`);
    const tmp = utils_1.tmpDir();
    const caKeyPath = path_1.join(tmp.name, 'ca.key');
    const caCertPath = path_1.join(caKeyPath, '..', 'ca.crt');
    const caKey = await platforms_1.default.readProtectedFile(constants_1.rootCAKeyPath);
    const caCrt = await platforms_1.default.readProtectedFile(constants_1.rootCACertPath);
    fs_1.writeFileSync(caKeyPath, caKey);
    fs_1.writeFileSync(caCertPath, caCrt);
    await cb({ caKeyPath, caCertPath });
    fs_1.unlinkSync(caKeyPath);
    fs_1.unlinkSync(caCertPath);
    tmp.removeCallback();
}
exports.withCertificateAuthorityCredentials = withCertificateAuthorityCredentials;
async function saveCertificateAuthorityCredentials(keypath) {
    debug(`Saving devcert's certificate authority credentials`);
    const key = fs_1.readFileSync(keypath, 'utf-8');
    await platforms_1.default.writeProtectedFile(constants_1.rootCAKeyPath, key);
}
function certErrors() {
    try {
        utils_1.openssl(`x509 -in "${constants_1.rootCACertPath}" -noout`, 'checking for certificate errors');
        return '';
    }
    catch (e) {
        return e.toString();
    }
}
// This function helps to migrate from v1.0.x to >= v1.1.0.
/**
 * Smoothly migrate the certificate storage from v1.0.x to >= v1.1.0.
 * In v1.1.0 there are new options for retrieving the CA cert directly,
 * to help third-party Node apps trust the root CA.
 *
 * If a v1.0.x cert already exists, then devcert has written it with
 * platform.writeProtectedFile(), so an unprivileged readFile cannot access it.
 * Pre-detect and remedy this; it should only happen once per installation.
 */
async function ensureCACertReadable(options, certOptions) {
    if (!certErrors()) {
        return;
    }
    /**
     * on windows, writeProtectedFile left the cert encrypted on *nix, the cert
     * has no read permissions either way, openssl will fail and that means we
     * have to fix it
     */
    try {
        const caFileContents = await platforms_1.default.readProtectedFile(constants_1.rootCACertPath);
        platforms_1.default.deleteProtectedFiles(constants_1.rootCACertPath);
        fs_1.writeFileSync(constants_1.rootCACertPath, caFileContents);
    }
    catch (e) {
        return installCertificateAuthority(options, certOptions);
    }
    // double check that we have a live one
    const remainingErrors = certErrors();
    if (remainingErrors) {
        return installCertificateAuthority(options, certOptions);
    }
}
exports.ensureCACertReadable = ensureCACertReadable;
/**
 * Remove as much of the devcert files and state as we can. This is necessary
 * when generating a new root certificate, and should be available to API
 * consumers as well.
 *
 * Not all of it will be removable. If certutil is not installed, we'll leave
 * Firefox alone. We try to remove files with maximum permissions, and if that
 * fails, we'll silently fail.
 *
 * It's also possible that the command to untrust will not work, and we'll
 * silently fail that as well; with no existing certificates anymore, the
 * security exposure there is minimal.
 *
 * @public
 */
function uninstall() {
    platforms_1.default.removeFromTrustStores(constants_1.rootCACertPath);
    platforms_1.default.deleteProtectedFiles(constants_1.domainsDir);
    platforms_1.default.deleteProtectedFiles(constants_1.rootCADir);
    platforms_1.default.deleteProtectedFiles(constants_1.getLegacyConfigDir());
}
exports.uninstall = uninstall;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2VydGlmaWNhdGUtYXV0aG9yaXR5LmpzIiwic291cmNlUm9vdCI6Ii4vIiwic291cmNlcyI6WyJzcmMvY2VydGlmaWNhdGUtYXV0aG9yaXR5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsMkJBSVk7QUFDWixxQ0FBcUM7QUFFckMsMkNBV3FCO0FBQ3JCLDJDQUEwQztBQUMxQyxtQ0FBMEM7QUFDMUMsaURBQTZDO0FBRTdDLCtCQUE0QjtBQUU1QixNQUFNLEtBQUssR0FBRyxXQUFXLENBQUMsK0JBQStCLENBQUMsQ0FBQztBQUUzRDs7O0dBR0c7QUFDWSxLQUFLLFVBQVUsMkJBQTJCLENBQ3ZELFVBQW1CLEVBQUUsRUFDckIsV0FBd0I7SUFFeEIsS0FBSyxDQUNILHFGQUFxRixDQUN0RixDQUFDO0lBQ0YsU0FBUyxFQUFFLENBQUM7SUFDWiw0QkFBZ0IsRUFBRSxDQUFDO0lBRW5CLE1BQU0sR0FBRyxHQUFHLGNBQU0sRUFBRSxDQUFDO0lBQ3JCLEtBQUssQ0FBQyx3REFBd0QsQ0FBQyxDQUFDO0lBQ2hFLE1BQU0sV0FBVyxHQUFHLFdBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBRTdDLEtBQUssQ0FDSCxnRkFBZ0YsQ0FDakYsQ0FBQztJQUNGLGVBQWUsRUFBRSxDQUFDO0lBRWxCLEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO0lBQ2xDLDBCQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7SUFFekIsS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUM7SUFDckMsZUFBTyxDQUNMLDJCQUEyQiw0QkFBZ0IsV0FBVyxXQUFXLFdBQVcsMEJBQWMsV0FBVyxXQUFXLENBQUMsWUFBWSxFQUFFLEVBQy9ILG1CQUFtQixDQUNwQixDQUFDO0lBRUYsS0FBSyxDQUFDLDBDQUEwQyxDQUFDLENBQUM7SUFDbEQsTUFBTSxtQ0FBbUMsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUV2RCxLQUFLLENBQUMsdURBQXVELENBQUMsQ0FBQztJ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Ozs7Ozs7Ozs7OztHQWNHO0FBQ0gsU0FBZ0IsU0FBUztJQUN2QixtQkFBZSxDQUFDLHFCQUFxQixDQUFDLDBCQUFjLENBQUMsQ0FBQztJQUN0RCxtQkFBZSxDQUFDLG9CQUFvQixDQUFDLHNCQUFVLENBQUMsQ0FBQztJQUNqRCxtQkFBZSxDQUFDLG9CQUFvQixDQUFDLHFCQUFTLENBQUMsQ0FBQztJQUNoRCxtQkFBZSxDQUFDLG9CQUFvQixDQUFDLDhCQUFrQixFQUFFLENBQUMsQ0FBQztBQUM3RCxDQUFDO0FBTEQsOEJBS0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICByZWFkRmlsZVN5bmMgYXMgcmVhZEZpbGUsXG4gIHdyaXRlRmlsZVN5bmMgYXMgd3JpdGVGaWxlLFxuICB1bmxpbmtTeW5jXG59IGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIGNyZWF0ZURlYnVnIGZyb20gJ2RlYnVnJztcblxuaW1wb3J0IHtcbiAgZG9tYWluc0RpcixcbiAgcm9vdENBRGlyLFxuICBlbnN1cmVDb25maWdEaXJzLFxuICBnZXRMZWdhY3lDb25maWdEaXIsXG4gIHJvb3RDQUtleVBhdGgsXG4gIHJvb3RDQUNlcnRQYXRoLFxuICBjYVNlbGZTaWduQ29uZmlnLFxuICBvcGVuc3NsU2VyaWFsRmlsZVBhdGgsXG4gIG9wZW5zc2xEYXRhYmFzZUZpbGVQYXRoLFxuICBjYVZlcnNpb25GaWxlXG59IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBjdXJyZW50UGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybXMnO1xuaW1wb3J0IHsgb3BlbnNzbCwgdG1wRGlyIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUtleSB9IGZyb20gJy4vY2VydGlmaWNhdGVzJztcbmltcG9ydCB7IE9wdGlvbnMsIENlcnRPcHRpb25zIH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XG5cbmNvbnN0IGRlYnVnID0gY3JlYXRlRGVidWcoJ2RldmNlcnQ6Y2VydGlmaWNhdGUtYXV0aG9yaXR5Jyk7XG5cbi8qKlxuICogSW5zdGFsbCB0aGUgb25jZS1wZXItbWFjaGluZSB0cnVzdGVkIHJvb3QgQ0EuIFdlJ2xsIHVzZSB0aGlzIENBIHRvIHNpZ25cbiAqIHBlci1hcHAgY2VydHMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGluc3RhbGxDZXJ0aWZpY2F0ZUF1dGhvcml0eShcbiAgb3B0aW9uczogT3B0aW9ucyA9IHt9LFxuICBjZXJ0T3B0aW9uczogQ2VydE9wdGlvbnNcbik6IFByb21pc2U8dm9pZD4ge1xuICBkZWJ1ZyhcbiAgICBgVW5pbnN0YWxsaW5nIGV4aXN0aW5nIGNlcnRpZmljYXRlcywgd2hpY2ggd2lsbCBiZSB2b2lkIG9uY2UgYW55IGV4aXN0aW5nIENBIGlzIGdvbmVgXG4gICk7XG4gIHVuaW5zdGFsbCgpO1xuICBlbnN1cmVDb25maWdEaXJzKCk7XG5cbiAgY29uc3QgdG1wID0gdG1wRGlyKCk7XG4gIGRlYnVnKGBNYWtpbmcgYSB0ZW1wIHdvcmtpbmcgZGlyZWN0b3J5IGZvciBmaWxlcyB0byBjb3BpZWQgaW5gKTtcbiAgY29uc3Qgcm9vdEtleVBhdGggPSBqb2luKHRtcC5uYW1lLCAnY2Eua2V5Jyk7XG5cbiAgZGVidWcoXG4gICAgYEdlbmVyYXRpbmcgdGhlIE9wZW5TU0wgY29uZmlndXJhdGlvbiBuZWVkZWQgdG8gc2V0dXAgdGhlIGNlcnRpZmljYXRlIGF1dGhvcml0eWBcbiAgKTtcbiAgc2VlZENvbmZpZ0ZpbGVzKCk7XG5cbiAgZGVidWcoYEdlbmVyYXRpbmcgYSBwcml2YXRlIGtleWApO1xuICBnZW5lcmF0ZUtleShyb290S2V5UGF0aCk7XG5cbiAgZGVidWcoYEdlbmVyYXRpbmcgYSBDQSBjZXJ0aWZpY2F0ZWApO1xuICBvcGVuc3NsKFxuICAgIGByZXEgLW5ldyAteDUwOSAtY29uZmlnIFwiJHtjYVNlbGZTaWduQ29uZmlnfVwiIC1rZXkgXCIke3Jvb3RLZXlQYXRofVwiIC1vdXQgXCIke3Jvb3RDQUNlcnRQYXRofVwiIC1kYXlzICR7Y2VydE9wdGlvbnMuY2FDZXJ0RXhwaXJ5fWAsXG4gICAgJ2dlbmVyYXRpbmcgQ0EgQ1NSJ1xuICApO1xuXG4gIGRlYnVnKCdTYXZpbmcgY2VydGlmaWNhdGUgYXV0aG9yaXR5IGNyZWRlbnRpYWxzJyk7XG4gIGF3YWl0IHNhdmVDZXJ0aWZpY2F0ZUF1dGhvcml0eUNyZWRlbnRpYWxzKHJvb3RLZXlQYXRoKTtcblxuICBkZWJ1ZyhgQWRkaW5nIHRoZSByb290IGNlcnRpZmljYXRlIGF1dGhvcml0eSB0byB0cnVzdCBzdG9yZXNgKTtcbiAgYXdhaXQgY3VycmVudFBsYXRmb3JtLmFkZFRvVHJ1c3RTdG9yZXMocm9vdENBQ2VydFBhdGgsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBmaWxlcyBPcGVuU1NMIG5lZWRzIHRvIHNpZ24gY2VydGlmaWNhdGVzIGFzIGEgY2VydGlmaWNhdGVcbiAqIGF1dGhvcml0eSwgYXMgd2VsbCBhcyBvdXIgQ0Egc2V0dXAgdmVyc2lvblxuICovXG5mdW5jdGlvbiBzZWVkQ29uZmlnRmlsZXMoKTogdm9pZCB7XG4gIC8vIFRoaXMgaXMgdjIgb2YgdGhlIGRldmNlcnQgY2VydGlmaWNhdGUgYXV0aG9yaXR5IHNldHVwXG4gIHdyaXRlRmlsZShjYVZlcnNpb25GaWxlLCAnMicpO1xuICAvLyBPcGVuU1NMIENBIGZpbGVzXG4gIHdyaXRlRmlsZShvcGVuc3NsRGF0YWJhc2VGaWxlUGF0aCwgJycpO1xuICB3cml0ZUZpbGUob3BlbnNzbFNlcmlhbEZpbGVQYXRoLCAnMDEnKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdpdGhDZXJ0aWZpY2F0ZUF1dGhvcml0eUNyZWRlbnRpYWxzKFxuICBjYjogKHtcbiAgICBjYUtleVBhdGgsXG4gICAgY2FDZXJ0UGF0aFxuICB9OiB7XG4gICAgY2FLZXlQYXRoOiBzdHJpbmc7XG4gICAgY2FDZXJ0UGF0aDogc3RyaW5nO1xuICB9KSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGRlYnVnKGBSZXRyaWV2aW5nIGRldmNlcnQncyBjZXJ0aWZpY2F0ZSBhdXRob3JpdHkgY3JlZGVudGlhbHNgKTtcbiAgY29uc3QgdG1wID0gdG1wRGlyKCk7XG4gIGNvbnN0IGNhS2V5UGF0aCA9IGpvaW4odG1wLm5hbWUsICdjYS5rZXknKTtcbiAgY29uc3QgY2FDZXJ0UGF0aCA9IGpvaW4oY2FLZXlQYXRoLCAnLi4nLCAnY2EuY3J0Jyk7XG4gIGNvbnN0IGNhS2V5ID0gYXdhaXQgY3VycmVudFBsYXRmb3JtLnJlYWRQcm90ZWN0ZWRGaWxlKHJvb3RDQUtleVBhdGgpO1xuICBjb25zdCBjYUNydCA9IGF3YWl0IGN1cnJlbnRQbGF0Zm9ybS5yZWFkUHJvdGVjdGVkRmlsZShyb290Q0FDZXJ0UGF0aCk7XG4gIHdyaXRlRmlsZShjYUtleVBhdGgsIGNhS2V5KTtcbiAgd3JpdGVGaWxlKGNhQ2VydFBhdGgsIGNhQ3J0KTtcbiAgYXdhaXQgY2IoeyBjYUtleVBhdGgsIGNhQ2VydFBhdGggfSk7XG4gIHVubGlua1N5bmMoY2FLZXlQYXRoKTtcbiAgdW5saW5rU3luYyhjYUNlcnRQYXRoKTtcbiAgdG1wLnJlbW92ZUNhbGxiYWNrKCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNhdmVDZXJ0aWZpY2F0ZUF1dGhvcml0eUNyZWRlbnRpYWxzKFxuICBrZXlwYXRoOiBzdHJpbmdcbik6IFByb21pc2U8dm9pZD4ge1xuICBkZWJ1ZyhgU2F2aW5nIGRldmNlcnQncyBjZXJ0aWZpY2F0ZSBhdXRob3JpdHkgY3JlZGVudGlhbHNgKTtcbiAgY29uc3Qga2V5ID0gcmVhZEZpbGUoa2V5cGF0aCwgJ3V0Zi04Jyk7XG4gIGF3YWl0IGN1cnJlbnRQbGF0Zm9ybS53cml0ZVByb3RlY3RlZEZpbGUocm9vdENBS2V5UGF0aCwga2V5KTtcbn1cblxuZnVuY3Rpb24gY2VydEVycm9ycygpOiBzdHJpbmcge1xuICB0cnkge1xuICAgIG9wZW5zc2woXG4gICAgICBgeDUwOSAtaW4gXCIke3Jvb3RDQUNlcnRQYXRofVwiIC1ub291dGAsXG4gICAgICAnY2hlY2tpbmcgZm9yIGNlcnRpZmljYXRlIGVycm9ycydcbiAgICApO1xuICAgIHJldHVybiAnJztcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlLnRvU3RyaW5nKCk7XG4gIH1cbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBoZWxwcyB0byBtaWdyYXRlIGZyb20gdjEuMC54IHRvID49IHYxLjEuMC5cbi8qKlxuICogU21vb3RobHkgbWlncmF0ZSB0aGUgY2VydGlmaWNhdGUgc3RvcmFnZSBmcm9tIHYxLjAueCB0byA+PSB2MS4xLjAuXG4gKiBJbiB2MS4xLjAgdGhlcmUgYXJlIG5ldyBvcHRpb25zIGZvciByZXRyaWV2aW5nIHRoZSBDQSBjZXJ0IGRpcmVjdGx5LFxuICogdG8gaGVscCB0aGlyZC1wYXJ0eSBOb2RlIGFwcHMgdHJ1c3QgdGhlIHJvb3QgQ0EuXG4gKlxuICogSWYgYSB2MS4wLnggY2VydCBhbHJlYWR5IGV4aXN0cywgdGhlbiBkZXZjZXJ0IGhhcyB3cml0dGVuIGl0IHdpdGhcbiAqIHBsYXRmb3JtLndyaXRlUHJvdGVjdGVkRmlsZSgpLCBzbyBhbiB1bnByaXZpbGVnZWQgcmVhZEZpbGUgY2Fubm90IGFjY2VzcyBpdC5cbiAqIFByZS1kZXRlY3QgYW5kIHJlbWVkeSB0aGlzOyBpdCBzaG91bGQgb25seSBoYXBwZW4gb25jZSBwZXIgaW5zdGFsbGF0aW9uLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5zdXJlQ0FDZXJ0UmVhZGFibGUoXG4gIG9wdGlvbnM6IE9wdGlvbnMsXG4gIGNlcnRPcHRpb25zOiBDZXJ0T3B0aW9uc1xuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmICghY2VydEVycm9ycygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKlxuICAgKiBvbiB3aW5kb3dzLCB3cml0ZVByb3RlY3RlZEZpbGUgbGVmdCB0aGUgY2VydCBlbmNyeXB0ZWQgb24gKm5peCwgdGhlIGNlcnRcbiAgICogaGFzIG5vIHJlYWQgcGVybWlzc2lvbnMgZWl0aGVyIHdheSwgb3BlbnNzbCB3aWxsIGZhaWwgYW5kIHRoYXQgbWVhbnMgd2VcbiAgICogaGF2ZSB0byBmaXggaXRcbiAgICovXG4gIHRyeSB7XG4gICAgY29uc3QgY2FGaWxlQ29udGVudHMgPSBhd2FpdCBjdXJyZW50UGxhdGZvcm0ucmVhZFByb3RlY3RlZEZpbGUoXG4gICAgICByb290Q0FDZXJ0UGF0aFxuICAgICk7XG4gICAgY3VycmVudFBsYXRmb3JtLmRlbGV0ZVByb3RlY3RlZEZpbGVzKHJvb3RDQUNlcnRQYXRoKTtcbiAgICB3cml0ZUZpbGUocm9vdENBQ2VydFBhdGgsIGNhRmlsZUNvbnRlbnRzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBpbnN0YWxsQ2VydGlmaWNhdGVBdXRob3JpdHkob3B0aW9ucywgY2VydE9wdGlvbnMpO1xuICB9XG5cbiAgLy8gZG91YmxlIGNoZWNrIHRoYXQgd2UgaGF2ZSBhIGxpdmUgb25lXG4gIGNvbnN0IHJlbWFpbmluZ0Vycm9ycyA9IGNlcnRFcnJvcnMoKTtcbiAgaWYgKHJlbWFpbmluZ0Vycm9ycykge1xuICAgIHJldHVybiBpbnN0YWxsQ2VydGlmaWNhdGVBdXRob3JpdHkob3B0aW9ucywgY2VydE9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGFzIG11Y2ggb2YgdGhlIGRldmNlcnQgZmlsZXMgYW5kIHN0YXRlIGFzIHdlIGNhbi4gVGhpcyBpcyBuZWNlc3NhcnlcbiAqIHdoZW4gZ2VuZXJhdGluZyBhIG5ldyByb290IGNlcnRpZmljYXRlLCBhbmQgc2hvdWxkIGJlIGF2YWlsYWJsZSB0byBBUElcbiAqIGNvbnN1bWVycyBhcyB3ZWxsLlxuICpcbiAqIE5vdCBhbGwgb2YgaXQgd2lsbCBiZSByZW1vdmFibGUuIElmIGNlcnR1dGlsIGlzIG5vdCBpbnN0YWxsZWQsIHdlJ2xsIGxlYXZlXG4gKiBGaXJlZm94IGFsb25lLiBXZSB0cnkgdG8gcmVtb3ZlIGZpbGVzIHdpdGggbWF4aW11bSBwZXJtaXNzaW9ucywgYW5kIGlmIHRoYXRcbiAqIGZhaWxzLCB3ZSdsbCBzaWxlbnRseSBmYWlsLlxuICpcbiAqIEl0J3MgYWxzbyBwb3NzaWJsZSB0aGF0IHRoZSBjb21tYW5kIHRvIHVudHJ1c3Qgd2lsbCBub3Qgd29yaywgYW5kIHdlJ2xsXG4gKiBzaWxlbnRseSBmYWlsIHRoYXQgYXMgd2VsbDsgd2l0aCBubyBleGlzdGluZyBjZXJ0aWZpY2F0ZXMgYW55bW9yZSwgdGhlXG4gKiBzZWN1cml0eSBleHBvc3VyZSB0aGVyZSBpcyBtaW5pbWFsLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuaW5zdGFsbCgpOiB2b2lkIHtcbiAgY3VycmVudFBsYXRmb3JtLnJlbW92ZUZyb21UcnVzdFN0b3Jlcyhyb290Q0FDZXJ0UGF0aCk7XG4gIGN1cnJlbnRQbGF0Zm9ybS5kZWxldGVQcm90ZWN0ZWRGaWxlcyhkb21haW5zRGlyKTtcbiAgY3VycmVudFBsYXRmb3JtLmRlbGV0ZVByb3RlY3RlZEZpbGVzKHJvb3RDQURpcik7XG4gIGN1cnJlbnRQbGF0Zm9ybS5kZWxldGVQcm90ZWN0ZWRGaWxlcyhnZXRMZWdhY3lDb25maWdEaXIoKSk7XG59XG4iXX0=