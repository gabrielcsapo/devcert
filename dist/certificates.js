"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const createDebug = require("debug");
const fs_1 = require("fs");
const mkdirp_1 = require("mkdirp");
const certificate_authority_1 = require("./certificate-authority");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const debug = createDebug('devcert:certificates');
/**
 * Generate a domain certificate signed by the devcert root CA. Domain
 * certificates are cached in their own directories under
 * CONFIG_ROOT/domains/<domain>, and reused on subsequent requests. Because the
 * individual domain certificates are signed by the devcert root CA (which was
 * added to the OS/browser trust stores), they are trusted.
 */
async function generateDomainCertificate(commonName, alternativeNames, certOptions) {
    mkdirp_1.sync(utils_1.pathForDomain(commonName));
    debug(`Generating private key for ${commonName}`);
    const domainKeyPath = utils_1.pathForDomain(commonName, 'private-key.key');
    generateKey(domainKeyPath);
    debug(`Generating certificate signing request for ${commonName}`);
    const csrFile = utils_1.pathForDomain(commonName, `certificate-signing-request.csr`);
    await constants_1.withDomainSigningRequestConfig(commonName, { alternativeNames }, configpath => {
        utils_1.openssl(`req -new -config "${configpath}" -key "${domainKeyPath}" -out "${csrFile}" -days ${certOptions.domainCertExpiry}`, `generating CSR for ${commonName}`);
    });
    debug(`Generating certificate for ${commonName} from signing request and signing with root CA`);
    const domainCertPath = utils_1.pathForDomain(commonName, `certificate.crt`);
    await certificate_authority_1.withCertificateAuthorityCredentials(async ({ caKeyPath, caCertPath }) => {
        await constants_1.withDomainCertificateConfig(commonName, alternativeNames, domainCertConfigPath => {
            utils_1.openssl(`ca -config "${domainCertConfigPath}" -in "${csrFile}" -out "${domainCertPath}" -keyfile "${caKeyPath}" -cert "${caCertPath}" -days ${certOptions.domainCertExpiry} -batch`, `signing cert for ${commonName} with root ca`);
        });
    });
}
exports.generateDomainCertificate = generateDomainCertificate;
function isFile(pth) {
    return fs_1.statSync(pth).isFile();
}
/**
 * Revokes a domain certificate signed by the devcert root CA and deletes it.
 */
async function revokeDomainCertificate(commonName) {
    debug(`Revoking certificate for ${commonName}`);
    const domainCertPath = utils_1.certPathForDomain(commonName);
    assert(fs_1.existsSync(domainCertPath), 'domainCertPath must exist');
    assert(isFile(domainCertPath), 'domainCertPath must be a file');
    debug('domainCertPath', domainCertPath);
    assert(fs_1.readFileSync(domainCertPath).toString().length > 0, 'domainCert must be non-empty');
    await certificate_authority_1.withCertificateAuthorityCredentials(async ({ caKeyPath, caCertPath }) => {
        debug('caKeyPath', caKeyPath);
        debug('caCertPath', caCertPath);
        assert(fs_1.existsSync(caCertPath), 'ca cert must exist');
        assert(isFile(caCertPath), 'ca cert must be a file');
        assert(fs_1.existsSync(caKeyPath), 'ca key must exist');
        assert(isFile(caKeyPath), 'ca key must be a file');
        await constants_1.withDomainCertificateConfig(commonName, [], domainCertConfigPath => {
            assert(fs_1.existsSync(domainCertConfigPath), 'domainCertConfigPath must exist');
            assert(isFile(domainCertConfigPath), 'domainCertConfigPath must be a file');
            utils_1.openssl(`ca -config "${domainCertConfigPath}" -revoke "${domainCertPath}" -keyfile "${caKeyPath}" -cert "${caCertPath}"`, `revoking domain certificate for ${commonName}`);
        });
    }).catch(err => {
        throw new Error(`Problem revoking certificate\n${err}`);
    });
}
exports.revokeDomainCertificate = revokeDomainCertificate;
// Generate a cryptographic key, used to sign certificates or certificate signing requests.
function generateKey(filename) {
    debug(`generateKey: ${filename}`);
    utils_1.openssl(`genrsa -out "${filename}" 2048`, 'generating RSA key');
    fs_1.chmodSync(filename, 400);
}
exports.generateKey = generateKey;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2VydGlmaWNhdGVzLmpzIiwic291cmNlUm9vdCI6Ii4vIiwic291cmNlcyI6WyJjZXJ0aWZpY2F0ZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxpQ0FBaUM7QUFDakMscUNBQXFDO0FBQ3JDLDJCQUE0RTtBQUM1RSxtQ0FBd0M7QUFDeEMsbUVBQThFO0FBQzlFLDJDQUdxQjtBQUVyQixtQ0FBb0U7QUFFcEUsTUFBTSxLQUFLLEdBQUcsV0FBVyxDQUFDLHNCQUFzQixDQUFDLENBQUM7QUFFbEQ7Ozs7OztHQU1HO0FBQ0ksS0FBSyxVQUFVLHlCQUF5QixDQUM3QyxVQUFrQixFQUNsQixnQkFBMEIsRUFDMUIsV0FBd0I7SUFFeEIsYUFBTSxDQUFDLHFCQUFhLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztJQUVsQyxLQUFLLENBQUMsOEJBQThCLFVBQVUsRUFBRSxDQUFDLENBQUM7SUFDbEQsTUFBTSxhQUFhLEdBQUcscUJBQWEsQ0FBQyxVQUFVLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztJQUNuRSxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUM7SUFFM0IsS0FBSyxDQUFDLDhDQUE4QyxVQUFVLEVBQUUsQ0FBQyxDQUFDO0lBQ2xFLE1BQU0sT0FBTyxHQUFHLHFCQUFhLENBQUMsVUFBVSxFQUFFLGlDQUFpQyxDQUFDLENBQUM7SUFDN0UsTUFBTSwwQ0FBOEIsQ0FDbEMsVUFBVSxFQUNWLEVBQUUsZ0JBQWdCLEVBQUUsRUFDcEIsVUFBVSxDQUFDLEVBQUU7UUFDWCxlQUFPLENBQ0wscUJBQXFCLFVBQVUsV0FBVyxhQUFhLFdBQVcsT0FBTyxXQUFXLFdBQVcsQ0FBQyxnQkFBZ0IsRUFBRSxFQUNsSCxzQkFBc0IsVUFBVSxFQUFFLENBQ25DLENBQUM7SUFDSixDQUFDLENBQ0YsQ0FBQztJQUVGLEtBQUssQ0FDSCw4QkFBOEIsVUFBVSxnREFBZ0QsQ0FDekYsQ0FBQztJQUNGLE1BQU0sY0FBYyxHQUFHLHFCQUFhLENBQUMsVUFBVSxFQUFFLGlCQUFpQixD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QUFHLENBQUMsQ0FBQztBQUN2QixDQUFDO0FBSkQsa0NBSUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCAqIGFzIGNyZWF0ZURlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCB7IGNobW9kU3luYyBhcyBjaG1vZCwgZXhpc3RzU3luYywgc3RhdFN5bmMsIHJlYWRGaWxlU3luYyB9IGZyb20gJ2ZzJztcbmltcG9ydCB7IHN5bmMgYXMgbWtkaXJwIH0gZnJvbSAnbWtkaXJwJztcbmltcG9ydCB7IHdpdGhDZXJ0aWZpY2F0ZUF1dGhvcml0eUNyZWRlbnRpYWxzIH0gZnJvbSAnLi9jZXJ0aWZpY2F0ZS1hdXRob3JpdHknO1xuaW1wb3J0IHtcbiAgd2l0aERvbWFpbkNlcnRpZmljYXRlQ29uZmlnLFxuICB3aXRoRG9tYWluU2lnbmluZ1JlcXVlc3RDb25maWdcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQ2VydE9wdGlvbnMgfSBmcm9tICcuL2luZGV4JztcbmltcG9ydCB7IG9wZW5zc2wsIHBhdGhGb3JEb21haW4sIGNlcnRQYXRoRm9yRG9tYWluIH0gZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IGRlYnVnID0gY3JlYXRlRGVidWcoJ2RldmNlcnQ6Y2VydGlmaWNhdGVzJyk7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBkb21haW4gY2VydGlmaWNhdGUgc2lnbmVkIGJ5IHRoZSBkZXZjZXJ0IHJvb3QgQ0EuIERvbWFpblxuICogY2VydGlmaWNhdGVzIGFyZSBjYWNoZWQgaW4gdGhlaXIgb3duIGRpcmVjdG9yaWVzIHVuZGVyXG4gKiBDT05GSUdfUk9PVC9kb21haW5zLzxkb21haW4+LCBhbmQgcmV1c2VkIG9uIHN1YnNlcXVlbnQgcmVxdWVzdHMuIEJlY2F1c2UgdGhlXG4gKiBpbmRpdmlkdWFsIGRvbWFpbiBjZXJ0aWZpY2F0ZXMgYXJlIHNpZ25lZCBieSB0aGUgZGV2Y2VydCByb290IENBICh3aGljaCB3YXNcbiAqIGFkZGVkIHRvIHRoZSBPUy9icm93c2VyIHRydXN0IHN0b3JlcyksIHRoZXkgYXJlIHRydXN0ZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZURvbWFpbkNlcnRpZmljYXRlKFxuICBjb21tb25OYW1lOiBzdHJpbmcsXG4gIGFsdGVybmF0aXZlTmFtZXM6IHN0cmluZ1tdLFxuICBjZXJ0T3B0aW9uczogQ2VydE9wdGlvbnNcbik6IFByb21pc2U8dm9pZD4ge1xuICBta2RpcnAocGF0aEZvckRvbWFpbihjb21tb25OYW1lKSk7XG5cbiAgZGVidWcoYEdlbmVyYXRpbmcgcHJpdmF0ZSBrZXkgZm9yICR7Y29tbW9uTmFtZX1gKTtcbiAgY29uc3QgZG9tYWluS2V5UGF0aCA9IHBhdGhGb3JEb21haW4oY29tbW9uTmFtZSwgJ3ByaXZhdGUta2V5LmtleScpO1xuICBnZW5lcmF0ZUtleShkb21haW5LZXlQYXRoKTtcblxuICBkZWJ1ZyhgR2VuZXJhdGluZyBjZXJ0aWZpY2F0ZSBzaWduaW5nIHJlcXVlc3QgZm9yICR7Y29tbW9uTmFtZX1gKTtcbiAgY29uc3QgY3NyRmlsZSA9IHBhdGhGb3JEb21haW4oY29tbW9uTmFtZSwgYGNlcnRpZmljYXRlLXNpZ25pbmctcmVxdWVzdC5jc3JgKTtcbiAgYXdhaXQgd2l0aERvbWFpblNpZ25pbmdSZXF1ZXN0Q29uZmlnKFxuICAgIGNvbW1vbk5hbWUsXG4gICAgeyBhbHRlcm5hdGl2ZU5hbWVzIH0sXG4gICAgY29uZmlncGF0aCA9PiB7XG4gICAgICBvcGVuc3NsKFxuICAgICAgICBgcmVxIC1uZXcgLWNvbmZpZyBcIiR7Y29uZmlncGF0aH1cIiAta2V5IFwiJHtkb21haW5LZXlQYXRofVwiIC1vdXQgXCIke2NzckZpbGV9XCIgLWRheXMgJHtjZXJ0T3B0aW9ucy5kb21haW5DZXJ0RXhwaXJ5fWAsXG4gICAgICAgIGBnZW5lcmF0aW5nIENTUiBmb3IgJHtjb21tb25OYW1lfWBcbiAgICAgICk7XG4gICAgfVxuICApO1xuXG4gIGRlYnVnKFxuICAgIGBHZW5lcmF0aW5nIGNlcnRpZmljYXRlIGZvciAke2NvbW1vbk5hbWV9IGZyb20gc2lnbmluZyByZXF1ZXN0IGFuZCBzaWduaW5nIHdpdGggcm9vdCBDQWBcbiAgKTtcbiAgY29uc3QgZG9tYWluQ2VydFBhdGggPSBwYXRoRm9yRG9tYWluKGNvbW1vbk5hbWUsIGBjZXJ0aWZpY2F0ZS5jcnRgKTtcblxuICBhd2FpdCB3aXRoQ2VydGlmaWNhdGVBdXRob3JpdHlDcmVkZW50aWFscyhcbiAgICBhc3luYyAoeyBjYUtleVBhdGgsIGNhQ2VydFBhdGggfSkgPT4ge1xuICAgICAgYXdhaXQgd2l0aERvbWFpbkNlcnRpZmljYXRlQ29uZmlnKFxuICAgICAgICBjb21tb25OYW1lLFxuICAgICAgICBhbHRlcm5hdGl2ZU5hbWVzLFxuICAgICAgICBkb21haW5DZXJ0Q29uZmlnUGF0aCA9PiB7XG4gICAgICAgICAgb3BlbnNzbChcbiAgICAgICAgICAgIGBjYSAtY29uZmlnIFwiJHtkb21haW5DZXJ0Q29uZmlnUGF0aH1cIiAtaW4gXCIke2NzckZpbGV9XCIgLW91dCBcIiR7ZG9tYWluQ2VydFBhdGh9XCIgLWtleWZpbGUgXCIke2NhS2V5UGF0aH1cIiAtY2VydCBcIiR7Y2FDZXJ0UGF0aH1cIiAtZGF5cyAke2NlcnRPcHRpb25zLmRvbWFpbkNlcnRFeHBpcnl9IC1iYXRjaGAsXG4gICAgICAgICAgICBgc2lnbmluZyBjZXJ0IGZvciAke2NvbW1vbk5hbWV9IHdpdGggcm9vdCBjYWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNGaWxlKHB0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBzdGF0U3luYyhwdGgpLmlzRmlsZSgpO1xufVxuXG4vKipcbiAqIFJldm9rZXMgYSBkb21haW4gY2VydGlmaWNhdGUgc2lnbmVkIGJ5IHRoZSBkZXZjZXJ0IHJvb3QgQ0EgYW5kIGRlbGV0ZXMgaXQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXZva2VEb21haW5DZXJ0aWZpY2F0ZShcbiAgY29tbW9uTmFtZTogc3RyaW5nXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgZGVidWcoYFJldm9raW5nIGNlcnRpZmljYXRlIGZvciAke2NvbW1vbk5hbWV9YCk7XG4gIGNvbnN0IGRvbWFpbkNlcnRQYXRoID0gY2VydFBhdGhGb3JEb21haW4oY29tbW9uTmFtZSk7XG4gIGFzc2VydChleGlzdHNTeW5jKGRvbWFpbkNlcnRQYXRoKSwgJ2RvbWFpbkNlcnRQYXRoIG11c3QgZXhpc3QnKTtcbiAgYXNzZXJ0KGlzRmlsZShkb21haW5DZXJ0UGF0aCksICdkb21haW5DZXJ0UGF0aCBtdXN0IGJlIGEgZmlsZScpO1xuICBkZWJ1ZygnZG9tYWluQ2VydFBhdGgnLCBkb21haW5DZXJ0UGF0aCk7XG5cbiAgYXNzZXJ0KFxuICAgIHJlYWRGaWxlU3luYyhkb21haW5DZXJ0UGF0aCkudG9TdHJpbmcoKS5sZW5ndGggPiAwLFxuICAgICdkb21haW5DZXJ0IG11c3QgYmUgbm9uLWVtcHR5J1xuICApO1xuICBhd2FpdCB3aXRoQ2VydGlmaWNhdGVBdXRob3JpdHlDcmVkZW50aWFscyhcbiAgICBhc3luYyAoeyBjYUtleVBhdGgsIGNhQ2VydFBhdGggfSkgPT4ge1xuICAgICAgZGVidWcoJ2NhS2V5UGF0aCcsIGNhS2V5UGF0aCk7XG4gICAgICBkZWJ1ZygnY2FDZXJ0UGF0aCcsIGNhQ2VydFBhdGgpO1xuICAgICAgYXNzZXJ0KGV4aXN0c1N5bmMoY2FDZXJ0UGF0aCksICdjYSBjZXJ0IG11c3QgZXhpc3QnKTtcbiAgICAgIGFzc2VydChpc0ZpbGUoY2FDZXJ0UGF0aCksICdjYSBjZXJ0IG11c3QgYmUgYSBmaWxlJyk7XG4gICAgICBhc3NlcnQoZXhpc3RzU3luYyhjYUtleVBhdGgpLCAnY2Ega2V5IG11c3QgZXhpc3QnKTtcbiAgICAgIGFzc2VydChpc0ZpbGUoY2FLZXlQYXRoKSwgJ2NhIGtleSBtdXN0IGJlIGEgZmlsZScpO1xuICAgICAgYXdhaXQgd2l0aERvbWFpbkNlcnRpZmljYXRlQ29uZmlnKFxuICAgICAgICBjb21tb25OYW1lLFxuICAgICAgICBbXSxcbiAgICAgICAgZG9tYWluQ2VydENvbmZpZ1BhdGggPT4ge1xuICAgICAgICAgIGFzc2VydChcbiAgICAgICAgICAgIGV4aXN0c1N5bmMoZG9tYWluQ2VydENvbmZpZ1BhdGgpLFxuICAgICAgICAgICAgJ2RvbWFpbkNlcnRDb25maWdQYXRoIG11c3QgZXhpc3QnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhc3NlcnQoXG4gICAgICAgICAgICBpc0ZpbGUoZG9tYWluQ2VydENvbmZpZ1BhdGgpLFxuICAgICAgICAgICAgJ2RvbWFpbkNlcnRDb25maWdQYXRoIG11c3QgYmUgYSBmaWxlJ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBvcGVuc3NsKFxuICAgICAgICAgICAgYGNhIC1jb25maWcgXCIke2RvbWFpbkNlcnRDb25maWdQYXRofVwiIC1yZXZva2UgXCIke2RvbWFpbkNlcnRQYXRofVwiIC1rZXlmaWxlIFwiJHtjYUtleVBhdGh9XCIgLWNlcnQgXCIke2NhQ2VydFBhdGh9XCJgLFxuICAgICAgICAgICAgYHJldm9raW5nIGRvbWFpbiBjZXJ0aWZpY2F0ZSBmb3IgJHtjb21tb25OYW1lfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgKS5jYXRjaChlcnIgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihgUHJvYmxlbSByZXZva2luZyBjZXJ0aWZpY2F0ZVxcbiR7ZXJyfWApO1xuICB9KTtcbn1cblxuLy8gR2VuZXJhdGUgYSBjcnlwdG9ncmFwaGljIGtleSwgdXNlZCB0byBzaWduIGNlcnRpZmljYXRlcyBvciBjZXJ0aWZpY2F0ZSBzaWduaW5nIHJlcXVlc3RzLlxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlS2V5KGZpbGVuYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgZGVidWcoYGdlbmVyYXRlS2V5OiAke2ZpbGVuYW1lfWApO1xuICBvcGVuc3NsKGBnZW5yc2EgLW91dCBcIiR7ZmlsZW5hbWV9XCIgMjA0OGAsICdnZW5lcmF0aW5nIFJTQSBrZXknKTtcbiAgY2htb2QoZmlsZW5hbWUsIDQwMCk7XG59XG4iXX0=