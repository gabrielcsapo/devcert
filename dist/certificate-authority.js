"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const createDebug = require("debug");
const constants_1 = require("./constants");
const platforms_1 = require("./platforms");
const utils_1 = require("./utils");
const certificates_1 = require("./certificates");
const path_1 = require("path");
const debug = createDebug('devcert:certificate-authority');
/**
 * Install the once-per-machine trusted root CA. We'll use this CA to sign
 * per-app certs.
 */
async function installCertificateAuthority(options = {}, certOptions) {
    debug(`Uninstalling existing certificates, which will be void once any existing CA is gone`);
    uninstall();
    constants_1.ensureConfigDirs();
    const tmp = utils_1.tmpDir();
    debug(`Making a temp working directory for files to copied in`);
    const rootKeyPath = path_1.join(tmp.name, 'ca.key');
    debug(`Generating the OpenSSL configuration needed to setup the certificate authority`);
    seedConfigFiles();
    debug(`Generating a private key`);
    certificates_1.generateKey(rootKeyPath);
    debug(`Generating a CA certificate`);
    utils_1.openssl(`req -new -x509 -config "${constants_1.caSelfSignConfig}" -key "${rootKeyPath}" -out "${constants_1.rootCACertPath}" -days ${certOptions.caCertExpiry}`, 'generating CA CSR');
    debug('Saving certificate authority credentials');
    await saveCertificateAuthorityCredentials(rootKeyPath);
    debug(`Adding the root certificate authority to trust stores`);
    await platforms_1.default.addToTrustStores(constants_1.rootCACertPath, options);
}
exports.default = installCertificateAuthority;
/**
 * Initializes the files OpenSSL needs to sign certificates as a certificate
 * authority, as well as our CA setup version
 */
function seedConfigFiles() {
    // This is v2 of the devcert certificate authority setup
    fs_1.writeFileSync(constants_1.caVersionFile, '2');
    // OpenSSL CA files
    fs_1.writeFileSync(constants_1.opensslDatabaseFilePath, '');
    fs_1.writeFileSync(constants_1.opensslSerialFilePath, '01');
}
async function withCertificateAuthorityCredentials(cb) {
    debug(`Retrieving devcert's certificate authority credentials`);
    const tmp = utils_1.tmpDir();
    const caKeyPath = path_1.join(tmp.name, 'ca.key');
    const caCertPath = path_1.join(caKeyPath, '..', 'ca.crt');
    const caKey = await platforms_1.default.readProtectedFile(constants_1.rootCAKeyPath);
    const caCrt = await platforms_1.default.readProtectedFile(constants_1.rootCACertPath);
    fs_1.writeFileSync(caKeyPath, caKey);
    fs_1.writeFileSync(caCertPath, caCrt);
    await cb({ caKeyPath, caCertPath });
    fs_1.unlinkSync(caKeyPath);
    fs_1.unlinkSync(caCertPath);
    tmp.removeCallback();
}
exports.withCertificateAuthorityCredentials = withCertificateAuthorityCredentials;
async function saveCertificateAuthorityCredentials(keypath) {
    debug(`Saving devcert's certificate authority credentials`);
    const key = fs_1.readFileSync(keypath, 'utf-8');
    await platforms_1.default.writeProtectedFile(constants_1.rootCAKeyPath, key);
}
function certErrors() {
    try {
        utils_1.openssl(`x509 -in "${constants_1.rootCACertPath}" -noout`, 'checking for certificate errors');
        return '';
    }
    catch (e) {
        return e.toString();
    }
}
// This function helps to migrate from v1.0.x to >= v1.1.0.
/**
 * Smoothly migrate the certificate storage from v1.0.x to >= v1.1.0.
 * In v1.1.0 there are new options for retrieving the CA cert directly,
 * to help third-party Node apps trust the root CA.
 *
 * If a v1.0.x cert already exists, then devcert has written it with
 * platform.writeProtectedFile(), so an unprivileged readFile cannot access it.
 * Pre-detect and remedy this; it should only happen once per installation.
 */
async function ensureCACertReadable(options, certOptions) {
    if (!certErrors()) {
        return;
    }
    /**
     * on windows, writeProtectedFile left the cert encrypted on *nix, the cert
     * has no read permissions either way, openssl will fail and that means we
     * have to fix it
     */
    try {
        const caFileContents = await platforms_1.default.readProtectedFile(constants_1.rootCACertPath);
        platforms_1.default.deleteProtectedFiles(constants_1.rootCACertPath);
        fs_1.writeFileSync(constants_1.rootCACertPath, caFileContents);
    }
    catch (e) {
        return installCertificateAuthority(options, certOptions);
    }
    // double check that we have a live one
    const remainingErrors = certErrors();
    if (remainingErrors) {
        return installCertificateAuthority(options, certOptions);
    }
}
exports.ensureCACertReadable = ensureCACertReadable;
/**
 * Remove as much of the devcert files and state as we can. This is necessary
 * when generating a new root certificate, and should be available to API
 * consumers as well.
 *
 * Not all of it will be removable. If certutil is not installed, we'll leave
 * Firefox alone. We try to remove files with maximum permissions, and if that
 * fails, we'll silently fail.
 *
 * It's also possible that the command to untrust will not work, and we'll
 * silently fail that as well; with no existing certificates anymore, the
 * security exposure there is minimal.
 *
 * @public
 */
function uninstall() {
    platforms_1.default.removeFromTrustStores(constants_1.rootCACertPath);
    platforms_1.default.deleteProtectedFiles(constants_1.domainsDir);
    platforms_1.default.deleteProtectedFiles(constants_1.rootCADir);
    platforms_1.default.deleteProtectedFiles(constants_1.getLegacyConfigDir());
}
exports.uninstall = uninstall;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2VydGlmaWNhdGUtYXV0aG9yaXR5LmpzIiwic291cmNlUm9vdCI6Ii4vIiwic291cmNlcyI6WyJjZXJ0aWZpY2F0ZS1hdXRob3JpdHkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwyQkFJWTtBQUNaLHFDQUFxQztBQUVyQywyQ0FXcUI7QUFDckIsMkNBQTBDO0FBQzFDLG1DQUEwQztBQUMxQyxpREFBNkM7QUFFN0MsK0JBQTRCO0FBRTVCLE1BQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO0FBRTNEOzs7R0FHRztBQUNZLEtBQUssVUFBVSwyQkFBMkIsQ0FDdkQsVUFBbUIsRUFBRSxFQUNyQixXQUF3QjtJQUV4QixLQUFLLENBQ0gscUZBQXFGLENBQ3RGLENBQUM7SUFDRixTQUFTLEVBQUUsQ0FBQztJQUNaLDRCQUFnQixFQUFFLENBQUM7SUFFbkIsTUFBTSxHQUFHLEdBQUcsY0FBTSxFQUFFLENBQUM7SUFDckIsS0FBSyxDQUFDLHdEQUF3RCxDQUFDLENBQUM7SUFDaEUsTUFBTSxXQUFXLEdBQUcsV0FBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFFN0MsS0FBSyxDQUNILGdGQUFnRixDQUNqRixDQUFDO0lBQ0YsZUFBZSxFQUFFLENBQUM7SUFFbEIsS0FBSyxDQUFDLDBCQUEwQixDQUFDLENBQUM7SUFDbEMsMEJBQVcsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUV6QixLQUFLLENBQUMsNkJBQTZCLENBQUMsQ0FBQztJQUNyQyxlQUFPLENBQ0wsMkJBQTJCLDRCQUFnQixXQUFXLFdBQVcsV0FBVywwQkFBYyxXQUFXLFdBQVcsQ0FBQyxZQUFZLEVBQUUsRUFDL0gsbUJBQW1CLENBQ3BCLENBQUM7SUFFRixLQUFLLENBQUMsMENBQTBDLENBQUMsQ0FBQztJQUNsRCxNQUFNLG1DQUFtQyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBRXZELEtBQUssQ0FBQyx1REFBdUQsQ0FBQyxDQUFDO0lBQy9E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Ozs7Ozs7O0dBY0c7QUFDSCxTQUFnQixTQUFTO0lBQ3ZCLG1CQUFlLENBQUMscUJBQXFCLENBQUMsMEJBQWMsQ0FBQyxDQUFDO0lBQ3RELG1CQUFlLENBQUMsb0JBQW9CLENBQUMsc0JBQVUsQ0FBQyxDQUFDO0lBQ2pELG1CQUFlLENBQUMsb0JBQW9CLENBQUMscUJBQVMsQ0FBQyxDQUFDO0lBQ2hELG1CQUFlLENBQUMsb0JBQW9CLENBQUMsOEJBQWtCLEVBQUUsQ0FBQyxDQUFDO0FBQzdELENBQUM7QUFMRCw4QkFLQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIHJlYWRGaWxlU3luYyBhcyByZWFkRmlsZSxcbiAgd3JpdGVGaWxlU3luYyBhcyB3cml0ZUZpbGUsXG4gIHVubGlua1N5bmNcbn0gZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgY3JlYXRlRGVidWcgZnJvbSAnZGVidWcnO1xuXG5pbXBvcnQge1xuICBkb21haW5zRGlyLFxuICByb290Q0FEaXIsXG4gIGVuc3VyZUNvbmZpZ0RpcnMsXG4gIGdldExlZ2FjeUNvbmZpZ0RpcixcbiAgcm9vdENBS2V5UGF0aCxcbiAgcm9vdENBQ2VydFBhdGgsXG4gIGNhU2VsZlNpZ25Db25maWcsXG4gIG9wZW5zc2xTZXJpYWxGaWxlUGF0aCxcbiAgb3BlbnNzbERhdGFiYXNlRmlsZVBhdGgsXG4gIGNhVmVyc2lvbkZpbGVcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IGN1cnJlbnRQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3Jtcyc7XG5pbXBvcnQgeyBvcGVuc3NsLCB0bXBEaXIgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGdlbmVyYXRlS2V5IH0gZnJvbSAnLi9jZXJ0aWZpY2F0ZXMnO1xuaW1wb3J0IHsgT3B0aW9ucywgQ2VydE9wdGlvbnMgfSBmcm9tICcuL2luZGV4JztcbmltcG9ydCB7IGpvaW4gfSBmcm9tICdwYXRoJztcblxuY29uc3QgZGVidWcgPSBjcmVhdGVEZWJ1ZygnZGV2Y2VydDpjZXJ0aWZpY2F0ZS1hdXRob3JpdHknKTtcblxuLyoqXG4gKiBJbnN0YWxsIHRoZSBvbmNlLXBlci1tYWNoaW5lIHRydXN0ZWQgcm9vdCBDQS4gV2UnbGwgdXNlIHRoaXMgQ0EgdG8gc2lnblxuICogcGVyLWFwcCBjZXJ0cy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gaW5zdGFsbENlcnRpZmljYXRlQXV0aG9yaXR5KFxuICBvcHRpb25zOiBPcHRpb25zID0ge30sXG4gIGNlcnRPcHRpb25zOiBDZXJ0T3B0aW9uc1xuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGRlYnVnKFxuICAgIGBVbmluc3RhbGxpbmcgZXhpc3RpbmcgY2VydGlmaWNhdGVzLCB3aGljaCB3aWxsIGJlIHZvaWQgb25jZSBhbnkgZXhpc3RpbmcgQ0EgaXMgZ29uZWBcbiAgKTtcbiAgdW5pbnN0YWxsKCk7XG4gIGVuc3VyZUNvbmZpZ0RpcnMoKTtcblxuICBjb25zdCB0bXAgPSB0bXBEaXIoKTtcbiAgZGVidWcoYE1ha2luZyBhIHRlbXAgd29ya2luZyBkaXJlY3RvcnkgZm9yIGZpbGVzIHRvIGNvcGllZCBpbmApO1xuICBjb25zdCByb290S2V5UGF0aCA9IGpvaW4odG1wLm5hbWUsICdjYS5rZXknKTtcblxuICBkZWJ1ZyhcbiAgICBgR2VuZXJhdGluZyB0aGUgT3BlblNTTCBjb25maWd1cmF0aW9uIG5lZWRlZCB0byBzZXR1cCB0aGUgY2VydGlmaWNhdGUgYXV0aG9yaXR5YFxuICApO1xuICBzZWVkQ29uZmlnRmlsZXMoKTtcblxuICBkZWJ1ZyhgR2VuZXJhdGluZyBhIHByaXZhdGUga2V5YCk7XG4gIGdlbmVyYXRlS2V5KHJvb3RLZXlQYXRoKTtcblxuICBkZWJ1ZyhgR2VuZXJhdGluZyBhIENBIGNlcnRpZmljYXRlYCk7XG4gIG9wZW5zc2woXG4gICAgYHJlcSAtbmV3IC14NTA5IC1jb25maWcgXCIke2NhU2VsZlNpZ25Db25maWd9XCIgLWtleSBcIiR7cm9vdEtleVBhdGh9XCIgLW91dCBcIiR7cm9vdENBQ2VydFBhdGh9XCIgLWRheXMgJHtjZXJ0T3B0aW9ucy5jYUNlcnRFeHBpcnl9YCxcbiAgICAnZ2VuZXJhdGluZyBDQSBDU1InXG4gICk7XG5cbiAgZGVidWcoJ1NhdmluZyBjZXJ0aWZpY2F0ZSBhdXRob3JpdHkgY3JlZGVudGlhbHMnKTtcbiAgYXdhaXQgc2F2ZUNlcnRpZmljYXRlQXV0aG9yaXR5Q3JlZGVudGlhbHMocm9vdEtleVBhdGgpO1xuXG4gIGRlYnVnKGBBZGRpbmcgdGhlIHJvb3QgY2VydGlmaWNhdGUgYXV0aG9yaXR5IHRvIHRydXN0IHN0b3Jlc2ApO1xuICBhd2FpdCBjdXJyZW50UGxhdGZvcm0uYWRkVG9UcnVzdFN0b3Jlcyhyb290Q0FDZXJ0UGF0aCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGZpbGVzIE9wZW5TU0wgbmVlZHMgdG8gc2lnbiBjZXJ0aWZpY2F0ZXMgYXMgYSBjZXJ0aWZpY2F0ZVxuICogYXV0aG9yaXR5LCBhcyB3ZWxsIGFzIG91ciBDQSBzZXR1cCB2ZXJzaW9uXG4gKi9cbmZ1bmN0aW9uIHNlZWRDb25maWdGaWxlcygpOiB2b2lkIHtcbiAgLy8gVGhpcyBpcyB2MiBvZiB0aGUgZGV2Y2VydCBjZXJ0aWZpY2F0ZSBhdXRob3JpdHkgc2V0dXBcbiAgd3JpdGVGaWxlKGNhVmVyc2lvbkZpbGUsICcyJyk7XG4gIC8vIE9wZW5TU0wgQ0EgZmlsZXNcbiAgd3JpdGVGaWxlKG9wZW5zc2xEYXRhYmFzZUZpbGVQYXRoLCAnJyk7XG4gIHdyaXRlRmlsZShvcGVuc3NsU2VyaWFsRmlsZVBhdGgsICcwMScpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2l0aENlcnRpZmljYXRlQXV0aG9yaXR5Q3JlZGVudGlhbHMoXG4gIGNiOiAoe1xuICAgIGNhS2V5UGF0aCxcbiAgICBjYUNlcnRQYXRoXG4gIH06IHtcbiAgICBjYUtleVBhdGg6IHN0cmluZztcbiAgICBjYUNlcnRQYXRoOiBzdHJpbmc7XG4gIH0pID0+IFByb21pc2U8dm9pZD4gfCB2b2lkXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgZGVidWcoYFJldHJpZXZpbmcgZGV2Y2VydCdzIGNlcnRpZmljYXRlIGF1dGhvcml0eSBjcmVkZW50aWFsc2ApO1xuICBjb25zdCB0bXAgPSB0bXBEaXIoKTtcbiAgY29uc3QgY2FLZXlQYXRoID0gam9pbih0bXAubmFtZSwgJ2NhLmtleScpO1xuICBjb25zdCBjYUNlcnRQYXRoID0gam9pbihjYUtleVBhdGgsICcuLicsICdjYS5jcnQnKTtcbiAgY29uc3QgY2FLZXkgPSBhd2FpdCBjdXJyZW50UGxhdGZvcm0ucmVhZFByb3RlY3RlZEZpbGUocm9vdENBS2V5UGF0aCk7XG4gIGNvbnN0IGNhQ3J0ID0gYXdhaXQgY3VycmVudFBsYXRmb3JtLnJlYWRQcm90ZWN0ZWRGaWxlKHJvb3RDQUNlcnRQYXRoKTtcbiAgd3JpdGVGaWxlKGNhS2V5UGF0aCwgY2FLZXkpO1xuICB3cml0ZUZpbGUoY2FDZXJ0UGF0aCwgY2FDcnQpO1xuICBhd2FpdCBjYih7IGNhS2V5UGF0aCwgY2FDZXJ0UGF0aCB9KTtcbiAgdW5saW5rU3luYyhjYUtleVBhdGgpO1xuICB1bmxpbmtTeW5jKGNhQ2VydFBhdGgpO1xuICB0bXAucmVtb3ZlQ2FsbGJhY2soKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2F2ZUNlcnRpZmljYXRlQXV0aG9yaXR5Q3JlZGVudGlhbHMoXG4gIGtleXBhdGg6IHN0cmluZ1xuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGRlYnVnKGBTYXZpbmcgZGV2Y2VydCdzIGNlcnRpZmljYXRlIGF1dGhvcml0eSBjcmVkZW50aWFsc2ApO1xuICBjb25zdCBrZXkgPSByZWFkRmlsZShrZXlwYXRoLCAndXRmLTgnKTtcbiAgYXdhaXQgY3VycmVudFBsYXRmb3JtLndyaXRlUHJvdGVjdGVkRmlsZShyb290Q0FLZXlQYXRoLCBrZXkpO1xufVxuXG5mdW5jdGlvbiBjZXJ0RXJyb3JzKCk6IHN0cmluZyB7XG4gIHRyeSB7XG4gICAgb3BlbnNzbChcbiAgICAgIGB4NTA5IC1pbiBcIiR7cm9vdENBQ2VydFBhdGh9XCIgLW5vb3V0YCxcbiAgICAgICdjaGVja2luZyBmb3IgY2VydGlmaWNhdGUgZXJyb3JzJ1xuICAgICk7XG4gICAgcmV0dXJuICcnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGUudG9TdHJpbmcoKTtcbiAgfVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGhlbHBzIHRvIG1pZ3JhdGUgZnJvbSB2MS4wLnggdG8gPj0gdjEuMS4wLlxuLyoqXG4gKiBTbW9vdGhseSBtaWdyYXRlIHRoZSBjZXJ0aWZpY2F0ZSBzdG9yYWdlIGZyb20gdjEuMC54IHRvID49IHYxLjEuMC5cbiAqIEluIHYxLjEuMCB0aGVyZSBhcmUgbmV3IG9wdGlvbnMgZm9yIHJldHJpZXZpbmcgdGhlIENBIGNlcnQgZGlyZWN0bHksXG4gKiB0byBoZWxwIHRoaXJkLXBhcnR5IE5vZGUgYXBwcyB0cnVzdCB0aGUgcm9vdCBDQS5cbiAqXG4gKiBJZiBhIHYxLjAueCBjZXJ0IGFscmVhZHkgZXhpc3RzLCB0aGVuIGRldmNlcnQgaGFzIHdyaXR0ZW4gaXQgd2l0aFxuICogcGxhdGZvcm0ud3JpdGVQcm90ZWN0ZWRGaWxlKCksIHNvIGFuIHVucHJpdmlsZWdlZCByZWFkRmlsZSBjYW5ub3QgYWNjZXNzIGl0LlxuICogUHJlLWRldGVjdCBhbmQgcmVtZWR5IHRoaXM7IGl0IHNob3VsZCBvbmx5IGhhcHBlbiBvbmNlIHBlciBpbnN0YWxsYXRpb24uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbnN1cmVDQUNlcnRSZWFkYWJsZShcbiAgb3B0aW9uczogT3B0aW9ucyxcbiAgY2VydE9wdGlvbnM6IENlcnRPcHRpb25zXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgaWYgKCFjZXJ0RXJyb3JzKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqXG4gICAqIG9uIHdpbmRvd3MsIHdyaXRlUHJvdGVjdGVkRmlsZSBsZWZ0IHRoZSBjZXJ0IGVuY3J5cHRlZCBvbiAqbml4LCB0aGUgY2VydFxuICAgKiBoYXMgbm8gcmVhZCBwZXJtaXNzaW9ucyBlaXRoZXIgd2F5LCBvcGVuc3NsIHdpbGwgZmFpbCBhbmQgdGhhdCBtZWFucyB3ZVxuICAgKiBoYXZlIHRvIGZpeCBpdFxuICAgKi9cbiAgdHJ5IHtcbiAgICBjb25zdCBjYUZpbGVDb250ZW50cyA9IGF3YWl0IGN1cnJlbnRQbGF0Zm9ybS5yZWFkUHJvdGVjdGVkRmlsZShcbiAgICAgIHJvb3RDQUNlcnRQYXRoXG4gICAgKTtcbiAgICBjdXJyZW50UGxhdGZvcm0uZGVsZXRlUHJvdGVjdGVkRmlsZXMocm9vdENBQ2VydFBhdGgpO1xuICAgIHdyaXRlRmlsZShyb290Q0FDZXJ0UGF0aCwgY2FGaWxlQ29udGVudHMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGluc3RhbGxDZXJ0aWZpY2F0ZUF1dGhvcml0eShvcHRpb25zLCBjZXJ0T3B0aW9ucyk7XG4gIH1cblxuICAvLyBkb3VibGUgY2hlY2sgdGhhdCB3ZSBoYXZlIGEgbGl2ZSBvbmVcbiAgY29uc3QgcmVtYWluaW5nRXJyb3JzID0gY2VydEVycm9ycygpO1xuICBpZiAocmVtYWluaW5nRXJyb3JzKSB7XG4gICAgcmV0dXJuIGluc3RhbGxDZXJ0aWZpY2F0ZUF1dGhvcml0eShvcHRpb25zLCBjZXJ0T3B0aW9ucyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgYXMgbXVjaCBvZiB0aGUgZGV2Y2VydCBmaWxlcyBhbmQgc3RhdGUgYXMgd2UgY2FuLiBUaGlzIGlzIG5lY2Vzc2FyeVxuICogd2hlbiBnZW5lcmF0aW5nIGEgbmV3IHJvb3QgY2VydGlmaWNhdGUsIGFuZCBzaG91bGQgYmUgYXZhaWxhYmxlIHRvIEFQSVxuICogY29uc3VtZXJzIGFzIHdlbGwuXG4gKlxuICogTm90IGFsbCBvZiBpdCB3aWxsIGJlIHJlbW92YWJsZS4gSWYgY2VydHV0aWwgaXMgbm90IGluc3RhbGxlZCwgd2UnbGwgbGVhdmVcbiAqIEZpcmVmb3ggYWxvbmUuIFdlIHRyeSB0byByZW1vdmUgZmlsZXMgd2l0aCBtYXhpbXVtIHBlcm1pc3Npb25zLCBhbmQgaWYgdGhhdFxuICogZmFpbHMsIHdlJ2xsIHNpbGVudGx5IGZhaWwuXG4gKlxuICogSXQncyBhbHNvIHBvc3NpYmxlIHRoYXQgdGhlIGNvbW1hbmQgdG8gdW50cnVzdCB3aWxsIG5vdCB3b3JrLCBhbmQgd2UnbGxcbiAqIHNpbGVudGx5IGZhaWwgdGhhdCBhcyB3ZWxsOyB3aXRoIG5vIGV4aXN0aW5nIGNlcnRpZmljYXRlcyBhbnltb3JlLCB0aGVcbiAqIHNlY3VyaXR5IGV4cG9zdXJlIHRoZXJlIGlzIG1pbmltYWwuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gdW5pbnN0YWxsKCk6IHZvaWQge1xuICBjdXJyZW50UGxhdGZvcm0ucmVtb3ZlRnJvbVRydXN0U3RvcmVzKHJvb3RDQUNlcnRQYXRoKTtcbiAgY3VycmVudFBsYXRmb3JtLmRlbGV0ZVByb3RlY3RlZEZpbGVzKGRvbWFpbnNEaXIpO1xuICBjdXJyZW50UGxhdGZvcm0uZGVsZXRlUHJvdGVjdGVkRmlsZXMocm9vdENBRGlyKTtcbiAgY3VycmVudFBsYXRmb3JtLmRlbGV0ZVByb3RlY3RlZEZpbGVzKGdldExlZ2FjeUNvbmZpZ0RpcigpKTtcbn1cbiJdfQ==